/* Copyright 2017 Adrian Toncean; released under the MIT license */
const espace = {}

;(()=>{"use strict";function extract(source,pattern){const map={};function extract(source,pattern){if(pattern.type==="list"){if(source.type!=="list"||source.token.value!==pattern.token.value){return false}if(pattern.rest){if(source.children.length<pattern.rest.before+1+pattern.rest.after){return false}}else{if(source.children.length!==pattern.children.length){return false}}if(source.children[0].token.type!=="identifier"||source.children[0].token.value!==pattern.children[0].token.value){return false}if(pattern.rest){for(let i=1;i<=pattern.rest.before;i++){if(!extract(source.children[i],pattern.children[i])){return false}}map[pattern.rest.name]=source.children.slice(1+pattern.rest.before,source.children.length-pattern.rest.after);for(let i=0;i<pattern.rest.after;i++){if(!extract(source.children[source.children.length-pattern.rest.after+i],pattern.children[i+1+1+pattern.rest.before])){return false}}}else{for(let i=1;i<pattern.children.length;i++){if(!extract(source.children[i],pattern.children[i])){return false}}}return true}else{map[pattern.token.value]=source;return true}}return extract(source,pattern)?map:null}function deepClone(tree){const treeClone={type:tree.type,token:{type:tree.token.type,value:tree.token.value}};if(tree.type==="list"){treeClone.children=tree.children.map(deepClone)}return treeClone}function isPrefixed(string){return string.length>1&&string[0]==="_"}function inject(tree,map,suffixes){const suffixesThisRound={};function inject(tree){if(tree.children.length>0){const child=tree.children[0];if(isPrefixed(child.token.value)){if(!suffixesThisRound[child.token.value]){if(typeof suffixes[child.token.value]!=="undefined"){suffixes[child.token.value]++}else{suffixes[child.token.value]=0}suffixesThisRound[child.token.value]=`${child.token.value}_${suffixes[child.token.value]}`}child.token.value=suffixesThisRound[child.token.value]}}for(let i=1;i<tree.children.length;i++){const child=tree.children[i];if(child.token.type==="identifier"){const replaceTree=map[child.token.value];if(Array.isArray(replaceTree)){tree.children.splice(i,1,...replaceTree);i+=replaceTree.length-1}else if(replaceTree){tree.children[i]=replaceTree}else if(isPrefixed(child.token.value)){if(!suffixesThisRound[child.token.value]){if(typeof suffixes[child.token.value]!=="undefined"){suffixes[child.token.value]++}else{suffixes[child.token.value]=0}suffixesThisRound[child.token.value]=child.token.value+"_"+suffixes[child.token.value]}child.token.value=suffixesThisRound[child.token.value]}}else if(child.type==="list"){inject(child)}}}if(tree.token.type==="identifier"){const replaceTree=map[tree.token.value];if(replaceTree){tree.token=replaceTree.token;if(replaceTree.type==="list"){tree.children=replaceTree.children}}}else if(tree.type==="list"){inject(tree)}}function isRest(string){return string.length>3&&string.slice(-3)==="..."}function processForRest(tree){function traverse(tree){if(tree.type!=="list"){return}for(let i=1;i<tree.children.length;i++){const{token:token}=tree.children[i];if(token.type==="identifier"&&isRest(token.value)){tree.rest={before:i-1,after:tree.children.length-i-1,name:token.value}}else{traverse(tree.children[i])}}}traverse(tree)}function validatePattern(tree){const set=new Set;function traverse(tree){if(tree.children.length>0&&tree.children[0].token.type!=="identifier"){throw new Error(`Tokens of type ${tree.children[0].token.type} are not allowed in patterns`)}let rest=false;for(let i=1;i<tree.children.length;i++){const subTree=tree.children[i];if(subTree.token.type==="identifier"){if(isPrefixed(subTree.token.value)){throw new Error("Pattern can not contain variables prefixed by '_'")}if(set.has(subTree.token.value)){throw new Error(`Variable "${subTree.token.value}" already used in pattern`)}else{set.add(subTree.token.value)}if(isRest(subTree.token.value)){if(rest){throw new Error("Pattern can contain at most one rest variable on a level")}rest=true}}else if(subTree.type==="list"){traverse(subTree)}else{throw new Error(`Tokens of type ${subTree.token.type} are not allowed in patterns`)}}}if(tree.type==="list"){traverse(tree)}else{throw new Error("Pattern must not be an atom")}}function expand(source,pattern,substitute,suffixes={}){processForRest(pattern);function traverse(source){const map=extract(source,pattern);if(map){const newSubtree=deepClone(substitute);inject(newSubtree,map,suffixes);source.token=newSubtree.token;source.children=newSubtree.children}if(source.type==="list"){source.children.forEach(traverse)}}traverse(source)}espace.Expander={extract:extract,deepClone:deepClone,inject:inject,processForRest:processForRest,validatePattern:validatePattern,expand:expand}})();(()=>{"use strict";function raise(token,message){const exception=new Error(message);exception.coords=token.coords;throw exception}function makeList(token){if(token.type==="open"){return{type:"list",token:token,children:[]}}return{type:"list",token:token,children:[{type:"atom",token:{type:"identifier",value:token.value}}]}}function isMatching(open,closed){return open==="("&&closed===")"||open==="["&&closed==="]"||open==="{"&&closed==="}"}function parse(tokens){if(!tokens.length){return null}let root;const stack=[];let currentLevel=null;let token=tokens[0];if(token.type==="open"||token.type==="prefix"){currentLevel=makeList(token);root=currentLevel;stack.push(currentLevel)}else if(token.type==="closed"){raise(token,"Cannot start with )")}else{if(tokens.length>1){raise(token,"Unexpected token")}return{type:"atom",token:token}}for(let i=1;i<tokens.length;i++){token=tokens[i];if(!currentLevel){raise(token,"Unexpected token")}if(token.type==="open"||token.type==="prefix"){const newLevel=makeList(token);currentLevel.children.push(newLevel);currentLevel=newLevel;stack.push(currentLevel)}else{if(token.type==="closed"){const lastLevel=stack.pop();if(!isMatching(lastLevel.token.value,token.value)){raise(token,"Paren types must match")}currentLevel=stack[stack.length-1]}else{currentLevel.children.push({type:"atom",token:token})}while(currentLevel&&currentLevel.token.type==="prefix"){stack.pop();currentLevel=stack[stack.length-1]}}}if(stack.length>0){raise(token,"Missing )")}return root}espace.Parser={parse:parse}})();(()=>{"use strict";function serialize(expression){if(!expression){return""}if(expression.type==="list"){if(expression.token.type==="prefix"){return`${expression.token.value}${serialize(expression.children[0])}`}else{const childrenString=expression.children.map(serialize).join(" ");return expression.token.value==="("?`(${childrenString})`:expression.token.value==="["?`[${childrenString}]`:`{${childrenString}}`}}switch(expression.token.type){case"string":return`"${expression.token.value}"`;case"number":return""+expression.token.value;case"identifier":return expression.token.value}}espace.Serializer={serialize:serialize}})();(()=>{"use strict";function IterableString(string){this.string=string;this.pointer=0;this.marker=0;this.line=1;this.column=1}IterableString.prototype.advance=function(){if(this.current()==="\n"){this.line++;this.column=1}else{this.column++}this.pointer++};IterableString.prototype.setMarker=function(offset=0){this.marker=this.pointer+offset};IterableString.prototype.current=function(){return this.string.charAt(this.pointer)};IterableString.prototype.next=function(){return this.string.charAt(this.pointer+1)};IterableString.prototype.hasNext=function(){return this.pointer<this.string.length};IterableString.prototype.getMarked=function(offset=0){return this.string.substring(this.marker,this.pointer+offset)};IterableString.prototype.getCoords=function(){return{line:this.line,column:this.column}};espace.IterableString=IterableString})();(()=>{"use strict";function raise(coords,message){const exception=new Error(message);exception.coords=coords;throw exception}function tokenize(string,options={}){const whitespace=!!options.whitespace;const comments=!!options.comments;const coords=!!options.coords;const prefixes=options.prefixes||{};const makeToken=coords?(type,value,coords)=>({type:type,value:value,coords:coords}):(type,value)=>({type:type,value:value});const escape={"\\":"\\",n:"\n",t:"\t",'"':'"'};function chopString(str){const accumulated=[];str.advance();while(true){if(str.current()==="\\"){str.advance();if(escape[str.current()]){accumulated.push(escape[str.current()])}}else if(str.current()==='"'){str.advance();return makeToken("string",accumulated.join(""),str.getCoords())}else if(str.current()==="\n"||!str.hasNext()){raise(str.getCoords(),"String not properly ended")}else{accumulated.push(str.current())}str.advance()}}function chopNumber(str){str.setMarker();let tmp=str.current();while(tmp>="0"&&tmp<="9"){str.advance();tmp=str.current()}if(str.current()==="."){str.advance();let tmp=str.current();while(tmp>="0"&&tmp<="9"){str.advance();tmp=str.current()}}if(!")]} \n\t".includes(str.current())){raise(str.getCoords(),`Unexpected character '${str.current()}' after '${str.getMarked()}'`)}return makeToken("number",Number(str.getMarked()),str.getCoords())}function chopCommentMulti(str){str.setMarker(2);str.advance();str.advance();while(true){if(str.current()==="-"&&str.next()===";"){str.advance();str.advance();return makeToken("comment",str.getMarked(-2),str.getCoords())}else if(str.hasNext()){str.advance()}else{raise(str.getCoords(),"Multiline comment not properly terminated")}}}function chopCommentSingle(str){str.setMarker(1);str.advance();while(true){if(str.current()==="\n"||!str.hasNext()){str.advance();return makeToken("comment",str.getMarked(),str.getCoords())}else{str.advance()}}}function chopIdentifier(str){str.setMarker();let tmp=str.current();while(tmp>" "&&tmp<="~"&&tmp!=="("&&tmp!==")"&&tmp!=="["&&tmp!=="]"&&tmp!=="{"&&tmp!=="}"){str.advance();tmp=str.current()}return makeToken("identifier",str.getMarked(),str.getCoords())}function chopWhitespace(str){const tmp=str.current();str.advance();return makeToken("whitespace",tmp,str.getCoords())}return(()=>{const str=new espace.IterableString(string);const tokens=[];while(str.hasNext()){const current=str.current();if(current==='"'){tokens.push(chopString(str))}else if(current===";"){if(str.next()==="-"){const tmp=chopCommentMulti(str);if(comments){tokens.push(tmp)}}else{const tmp=chopCommentSingle(str);if(comments){tokens.push(tmp)}}}else if(current>="0"&&current<="9"){tokens.push(chopNumber(str))}else if(current==="("||current==="["||current==="{"){tokens.push(makeToken("open",current,str.getCoords()));str.advance()}else if(current===")"||current==="]"||current==="}"){tokens.push(makeToken("closed",current,str.getCoords()));str.advance()}else if(prefixes.hasOwnProperty(current)){tokens.push(makeToken("prefix",prefixes[current],str.getCoords()));str.advance()}else if(current>" "&&current<="~"){tokens.push(chopIdentifier(str))}else{const tmp=chopWhitespace(str);if(whitespace){tokens.push(tmp)}}}return tokens})()}espace.Tokenizer={tokenize:tokenize}})();


export { espace }